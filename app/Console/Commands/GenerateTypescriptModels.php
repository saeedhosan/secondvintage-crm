<?php

declare(strict_types=1);

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Str;

class GenerateTypescriptModels extends Command
{
    protected $signature = 'generate:ts-models';

    protected $description = 'Generate TypeScript interfaces from database schema';

    private const  DEFAULT_OUTPUT_PATH = 'src/types/models/models.ts';

    private const SQL_TO_TS_TYPE_MAP = [
        'int' => 'number',
        'bigint' => 'number',
        'smallint' => 'number',
        'tinyint' => 'number',
        'mediumint' => 'number',
        'decimal' => 'number',
        'float' => 'number',
        'double' => 'number',
        'real' => 'number',
        'varchar' => 'string',
        'char' => 'string',
        'text' => 'string',
        'mediumtext' => 'string',
        'longtext' => 'string',
        'date' => 'string',
        'datetime' => 'string',
        'timestamp' => 'string',
        'time' => 'string',
        'json' => 'any',
        'boolean' => 'boolean',
        'bit' => 'boolean',
    ];

    public function handle(): int
    {
        $database = $this->getDatabaseName();
        
        if (empty($database)) {
            $this->error('Database name not configured');
            return self::FAILURE;
        }

        $this->info("Generating TypeScript models from database: {$database}");

        try {
            $tables = $this->getAllTables($database);
            $foreignKeys = $this->getAllForeignKeys($database);
            
            $interfaces = $this->generateAllInterfaces($tables, $foreignKeys);
            
            $this->writeTypeScriptFile($interfaces);
            
            $this->info('TypeScript models generated successfully');
            return self::SUCCESS;
            
        } catch (\Exception $e) {
            $this->error("Error generating TypeScript models: {$e->getMessage()}");
            return self::FAILURE;
        }
    }

    private function getDatabaseName(): string
    {
        return config('database.connections.mysql.database') ?? '';
    }

    private function getAllTables(string $database): array
    {
        return DB::select("
            SELECT TABLE_NAME
            FROM information_schema.tables
            WHERE table_schema = ?
            AND TABLE_TYPE = 'BASE TABLE'
        ", [$database]);
    }

    private function getAllForeignKeys(string $database): array
    {
        return DB::select('
            SELECT TABLE_NAME, COLUMN_NAME, REFERENCED_TABLE_NAME, REFERENCED_COLUMN_NAME
            FROM information_schema.key_column_usage
            WHERE table_schema = ?
            AND REFERENCED_TABLE_NAME IS NOT NULL
        ', [$database]);
    }

    private function generateAllInterfaces(array $tables, array $foreignKeys): string
    {
        $fksByTable = $this->groupForeignKeysByTable($foreignKeys);
        $fksByReferencedTable = $this->groupForeignKeysByReferencedTable($foreignKeys);

        $content = "// Auto-generated by generate:ts-models\n\n";

        foreach ($tables as $table) {
            $tableName = $table->TABLE_NAME;
            $interfaceName = $this->convertTableNameToInterfaceName($tableName);
            $columns = $this->getTableColumns($database, $tableName);

            $content .= $this->generateInterface(
                $interfaceName,
                $columns,
                $fksByTable[$tableName] ?? [],
                $fksByReferencedTable[$tableName] ?? []
            );
        }

        return $content;
    }

    private function groupForeignKeysByTable(array $foreignKeys): array
    {
        $grouped = [];
        foreach ($foreignKeys as $foreignKey) {
            $grouped[$foreignKey->TABLE_NAME][] = $foreignKey;
        }
        return $grouped;
    }

    private function groupForeignKeysByReferencedTable(array $foreignKeys): array
    {
        $grouped = [];
        foreach ($foreignKeys as $foreignKey) {
            $grouped[$foreignKey->REFERENCED_TABLE_NAME][] = $foreignKey;
        }
        return $grouped;
    }

    private function getTableColumns(string $database, string $tableName): array
    {
        return DB::select('
            SELECT COLUMN_NAME, DATA_TYPE, IS_NULLABLE
            FROM information_schema.columns
            WHERE table_schema = ? AND table_name = ?
        ', [$database, $tableName]);
    }

    private function convertTableNameToInterfaceName(string $tableName): string
    {
        return Str::studly(Str::singular($tableName));
    }

    private function generateInterface(
        string $interfaceName,
        array $columns,
        array $belongsToRelations,
        array $hasManyRelations
    ): string {
        $interface = "export interface {$interfaceName} {\n";

        foreach ($columns as $column) {
            $tsType = $this->mapSqlTypeToTypeScript($column->DATA_TYPE);
            $nullable = $column->IS_NULLABLE === 'YES' ? ' | null' : '';
            $interface .= "  {$column->COLUMN_NAME}: {$tsType}{$nullable};\n";
        }

        foreach ($belongsToRelations as $relation) {
            $propertyName = Str::camel(str_replace('_id', '', $relation->COLUMN_NAME));
            $relatedInterface = $this->convertTableNameToInterfaceName($relation->REFERENCED_TABLE_NAME);
            $interface .= "  {$propertyName}?: {$relatedInterface};\n";
        }

        foreach ($hasManyRelations as $relation) {
            $relatedInterface = $this->convertTableNameToInterfaceName($relation->TABLE_NAME);
            $propertyName = Str::camel(Str::plural($relation->TABLE_NAME));
            $interface .= "  {$propertyName}?: {$relatedInterface}[];\n";
        }

        $interface .= "}\n\n";

        return $interface;
    }

    private function mapSqlTypeToTypeScript(string $sqlType): string
    {
        return self::SQL_TO_TS_TYPE_MAP[mb_strtolower($sqlType)] ?? 'any';
    }

    private function writeTypeScriptFile(string $content): void
    {
        $filePath = base_path(self::DEFAULT_OUTPUT_PATH);
        $directory = dirname($filePath);

        if (!is_dir($directory)) {
            mkdir($directory, recursive: true);
        }

        File::put($filePath, $content);
    }
}
